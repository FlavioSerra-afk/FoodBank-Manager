<?php
/**
 * Lightweight caching helper for FBM.
 *
 * @package FoodBankManager
 */

declare(strict_types=1);

namespace FoodBankManager\Core;

use function array_filter;
use function array_values;
use function delete_transient;
use function function_exists;
use function get_current_blog_id;
use function get_transient;
use function in_array;
use function is_array;
use function is_string;
use function md5;
use function explode;
use function sprintf;
use function set_transient;
use function wp_json_encode;

/**
 * Provides namespaced, version-aware cache utilities.
 */
final class Cache {
	private const PREFIX          = 'fbm:';
	private const REGISTRY_PREFIX = 'fbm_cache_registry:';
	private const REGISTRY_TTL    = 86400;

		/**
		 * Build a namespaced cache key for the provided group and payload.
		 *
		 * @param string               $group Cache namespace (e.g. `reports`).
		 * @param string               $type  Cache type (e.g. `summary`).
		 * @param array<string, mixed> $parts Additional context for the cache hash.
		 */
	public static function build_key( string $group, string $type, array $parts ): string {
			$site_id = function_exists( 'get_current_blog_id' ) ? (int) get_current_blog_id() : 0;
			$payload = wp_json_encode( $parts );

if ( ! is_string( $payload ) ) {
			// phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.serialize_serialize -- JSON fallback when wp_json_encode fails.
			$payload = serialize( $parts );
		}

			$hash = md5( $payload );

			return sprintf(
				'%s%s:v%s:%d:%s:%s',
				self::PREFIX,
				$group,
				Plugin::VERSION,
				$site_id,
				$type,
				$hash
			);
	}

		/**
		 * Retrieve a cached value for the provided key.
		 *
		 * @param string $key Cache key generated by {@see build_key()}.
		 *
		 * @return mixed Cached value or false when unavailable.
		 */
	public static function get( string $key ) {
			return get_transient( $key );
	}

		/**
		 * Store a cache value and remember the key for bulk invalidation.
		 *
		 * @param string $key   Cache key generated by {@see build_key()}.
		 * @param mixed  $value Value to cache.
		 * @param int    $ttl   Expiration in seconds.
		 */
	public static function set( string $key, $value, int $ttl ): void {
			set_transient( $key, $value, $ttl );
			self::remember_key( $key );
	}

		/**
		 * Delete a cached entry and remove it from the registry.
		 *
		 * @param string $key Cache key to delete.
		 */
	public static function delete( string $key ): void {
			delete_transient( $key );
			self::forget_key( $key );
	}

		/**
		 * Purge all cached entries tracked for the provided group.
		 *
		 * @param string $group Cache namespace to purge.
		 */
	public static function purge_group( string $group ): void {
			$registry_key = self::registry_key( $group );
			$keys         = get_transient( $registry_key );

		if ( is_array( $keys ) ) {
			foreach ( $keys as $key ) {
				if ( is_string( $key ) && '' !== $key ) {
						delete_transient( $key );
				}
			}
		}

			delete_transient( $registry_key );
	}

		/**
		 * Remember a cache key for bulk invalidation.
		 *
		 * @param string $key Cache key.
		 */
	private static function remember_key( string $key ): void {
			$group = self::extract_group( $key );

		if ( '' === $group ) {
				return;
		}

			$registry_key = self::registry_key( $group );
			$registry     = get_transient( $registry_key );

		if ( ! is_array( $registry ) ) {
				$registry = array();
		}

		if ( ! in_array( $key, $registry, true ) ) {
				$registry[] = $key;
				set_transient( $registry_key, array_values( $registry ), self::REGISTRY_TTL );
		}
	}

		/**
		 * Remove a cache key from the registry when deleted individually.
		 *
		 * @param string $key Cache key to remove.
		 */
	private static function forget_key( string $key ): void {
			$group = self::extract_group( $key );

		if ( '' === $group ) {
				return;
		}

			$registry_key = self::registry_key( $group );
			$registry     = get_transient( $registry_key );

		if ( ! is_array( $registry ) ) {
				return;
		}

			$filtered = array_filter(
				$registry,
				static function ( $entry ) use ( $key ) {
							return $entry !== $key;
				}
			);

		if ( empty( $filtered ) ) {
				delete_transient( $registry_key );

				return;
		}

			set_transient( $registry_key, array_values( $filtered ), self::REGISTRY_TTL );
	}

		/**
		 * Extract the cache group name from a full cache key.
		 *
		 * @param string $key Cache key generated by {@see build_key()}.
		 */
	private static function extract_group( string $key ): string {
		if ( '' === $key ) {
				return '';
		}

			$parts = explode( ':', $key );

			return isset( $parts[1] ) ? (string) $parts[1] : '';
	}

		/**
		 * Compose the registry key for a cache group.
		 *
		 * @param string $group Cache namespace.
		 */
	private static function registry_key( string $group ): string {
			$site_id = function_exists( 'get_current_blog_id' ) ? (int) get_current_blog_id() : 0;

			return sprintf( '%s%s:%d', self::REGISTRY_PREFIX, $group, $site_id );
	}
}
